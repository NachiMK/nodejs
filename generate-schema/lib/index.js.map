{"version":3,"sources":["../index.js"],"names":["_","require","moment","generator","Core","cores","Draft04","isUUID","module","exports","json","title","object","options","Object","assign","maxEnumValues","generateEnums","generateLengths","schema","addSchemaLimits","rootSchema","data","core","stats","each","value","pointer","schemaPointer","replace","stat","schemaUpdateFunctions","formats","length","anyNonNil","push","s","minLength","maxLength","isValid","format","ISO_8601","isNaN","type","values","keys","forEach","enum","slice","addFormatCounts","pickPopularFormat","size","findUpdatePopularformat","updateSchema","popularFormats","popularFormat","prevCnt","Cnt","splice","FormatName","Count","updateFunctions","schemaToUpdate","findSchema","fn","steps","split","step","console","log","Number","isInteger","parseInt","items","properties"],"mappings":"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","file":"index.js","sourcesContent":["const _ = require(\"lodash\");\nconst moment = require(\"moment\");\nconst generator = require(\"generate-schema\");\nconst Core = require(\"json-schema-library\").cores.Draft04;\nconst isUUID = require(\"is-uuid\");\n\n/**\n * @function json\n * @description This function returns the Json schema for given data\n *\n * @param {@title} : This is the name of the dynamo table or object you trying to find schema\n * @param {@object}: This is the data that you want to scan and come up with schema\n * @param {@options}: There are multiple options available:\n *  generateEnums :Set this to True if you want to include possible list of enums.\n *                 You can also set maxEnumValues to valid integer on how many enums you want to be returned.\n *  addFormatCounts: Set to true, if you want to know the number of keys that match each of the formats\n *  pickPopularFormat: Set to true, for picking the format based on populate percentage.\n */\nmodule.exports.json = function json(title, object, options = {}) {\n  options = Object.assign(\n    {},\n    { maxEnumValues: 20, generateEnums: false, generateLengths: false },\n    options\n  );\n\n  var schema = generator.json(title, object);\n  addSchemaLimits(schema, object, options);\n  return schema;\n};\n\nfunction addSchemaLimits(rootSchema, data, options) {\n  const core = new Core(rootSchema);\n  const stats = {};\n  // Queue up the schema updates\n  core.each(rootSchema, data, (schema, value, pointer) => {\n    const schemaPointer = pointer.replace(/(\\d+)/gi, \"*\").replace(\" / \", \" - \");\n    // Detect GUIDs and set min/max length to match data\n    // Also detect formats: date-time, date\n    if (typeof value !== \"object\" && typeof value !== \"array\") {\n      const stat = stats[schemaPointer] || { schemaUpdateFunctions: [] };\n      stat.formats = stat.formats || {};\n      if (value.length === 36 && isUUID.anyNonNil(value)) {\n        stat.schemaUpdateFunctions.push(s => {\n          s.minLength = 36;\n          s.maxLength = 36;\n        });\n        stat.formats[\"uuid\"] = (stat.formats[\"uuid\"] || 0) + 1;\n      } else if (moment(value, \"YYYY-MM-DD\", true).isValid()) {\n        stat.formats[\"date\"] = (stat.formats[\"date\"] || 0) + 1;\n        stat.schemaUpdateFunctions.push(s => (s.format = \"date\"));\n      } else if (moment(value, moment.ISO_8601, true).isValid()) {\n        stat.formats[\"date-time\"] = (stat.formats[\"date-time\"] || 0) + 1;\n        stat.schemaUpdateFunctions.push(s => (s.format = \"date-time\"));\n      } else if (!isNaN(value)) {\n        stat.formats[\"number\"] = (stat.formats[\"number\"] || 0) + 1;\n        stat.schemaUpdateFunctions.push(s => (s.format = \"number\"));\n      } else {\n        stat.formats[\"string\"] = (stat.formats[\"string\"] || 0) + 1;\n        stat.schemaUpdateFunctions.push(s => (s.format = \"string\"));\n      }\n\n      if (schema.type === \"string\") {\n        // TODO: Detect enumeration values.  This is harder to do efficiently inside the each.\n        // If total number of records > 100 but distinct values < 20 assume its an enum.\n        // Count the number of times the value has been used\n        stat.values = stat.values || {};\n        stat.values[value] = (stat.values[value] || 0) + 1;\n\n        // Keep stats on minLength and maxLength\n        if (value.length < (stat.minLength || 10000000)) {\n          stat.minLength = value.length;\n        }\n        if (value.length > (stat.maxLength || 0)) {\n          stat.maxLength = value.length;\n        }\n      }\n      stats[schemaPointer] = stat;\n    }\n  });\n\n  // Make the schema updates\n  Object.keys(stats).forEach(pointer => {\n    const stat = stats[pointer];\n    if (options.generateEnums && stat.values) {\n      stat.schemaUpdateFunctions.push(\n        s => (s.enum = Object.keys(stat.values).slice(0, options.maxEnumValues))\n      );\n    }\n    // // Add formats to schema if options were set for it.\n    if (options.addFormatCounts && stat.formats) {\n      stat.schemaUpdateFunctions.push(s => (s.formats = stat.formats));\n    }\n    // Cleanup format if multiple format exists and is requested in options\n    if (options.pickPopularFormat && _.size(stat.formats) > 1) {\n      findUpdatePopularformat(stat);\n    }\n    if (options.generateLengths && typeof stat.minLength !== \"undefined\") {\n      stat.schemaUpdateFunctions.push(s => {\n        s.minLength = stat.minLength;\n        s.maxLength = stat.maxLength;\n      });\n    }\n\n    updateSchema(rootSchema, pointer, stat.schemaUpdateFunctions);\n  });\n}\n\nfunction findUpdatePopularformat(stat) {\n  const popularFormats = [];\n  let popularFormat;\n  // pick the most occured one\n  let prevCnt = -1;\n  _.forEach(stat.formats, (Cnt, format) => {\n    if (Cnt >= prevCnt && Cnt >= 0) {\n      if (Cnt > prevCnt) {\n        popularFormats.splice(0);\n      }\n      popularFormats.push({\n        FormatName: format,\n        Count: Cnt\n      });\n      prevCnt = Cnt;\n    }\n  });\n  //if we have at least one popular format\n  // then let us find which one to use.\n  if (_.size(popularFormats) > 0) {\n    // they could be multiple formats that\n    // have same count as the popular one\n    // in that we have to pick the format\n    // that can hold all other formats.\n    if (_.size(popularFormats) > 1) {\n      // find which one to keep\n      _.forEach(popularFormats, format => {\n        if (format.FormatName === \"string\") {\n          popularFormat = format.FormatName;\n        } else if (\n          popularFormat === \"date\" &&\n          format.FormatName === \"date-time\"\n        ) {\n          popularFormat = format.FormatName;\n        } else if (\n          popularFormat !== \"string\" &&\n          format.FormatName !== \"string\"\n        ) {\n          popularFormat = \"string\";\n        }\n      });\n    } else {\n      // only one format so just pick it.\n      popularFormat = popularFormats[0].FormatName;\n    }\n  }\n  // set the new popular format\n  // stat.format = popularFormat || stat.format;\n  stat.schemaUpdateFunctions.push(\n    s => (s.format = popularFormat || stat.format)\n  );\n}\n\nfunction updateSchema(rootSchema, pointer, updateFunctions) {\n  if (updateFunctions.length === 0) {\n    return;\n  }\n  const schemaToUpdate = findSchema(rootSchema, pointer);\n  if (schemaToUpdate) {\n    updateFunctions.forEach(fn => {\n      fn(schemaToUpdate);\n    });\n  }\n}\n\nfunction findSchema(rootSchema, pointer) {\n  // Try to find the schema that needs to be updated\n  var steps = pointer.split(\"/\");\n  var schemaToUpdate = rootSchema;\n\n  steps.forEach(step => {\n    if (!schemaToUpdate) {\n      console.log(\"Could not get schema for pointer\", pointer);\n      return;\n    }\n    if (step === \"#\") {\n      return;\n    }\n    if (step === \"*\" || Number.isInteger(parseInt(step))) {\n      schemaToUpdate = schemaToUpdate.items;\n    } else {\n      if (schemaToUpdate) {\n        schemaToUpdate = schemaToUpdate.properties[step];\n      }\n    }\n  });\n  return schemaToUpdate;\n}\n"]}