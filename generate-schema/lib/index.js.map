{"version":3,"sources":["../index.js"],"names":["moment","require","generator","Core","cores","Draft04","isUUID","module","exports","json","title","object","options","Object","assign","maxEnumValues","generateEnums","generateLengths","schema","addSchemaLimits","rootSchema","data","core","stats","each","value","pointer","schemaPointer","replace","stat","schemaUpdateFunctions","length","anyNonNil","push","s","minLength","maxLength","isValid","format","ISO_8601","type","values","keys","forEach","enum","slice","updateSchema","updateFunctions","schemaToUpdate","findSchema","fn","steps","split","step","console","log","Number","isInteger","parseInt","items","properties"],"mappings":"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","file":"index.js","sourcesContent":["const moment = require('moment');\nconst generator = require('generate-schema');\nconst Core = require('json-schema-library').cores.Draft04;\nconst isUUID = require('is-uuid');\n\nmodule.exports.json = function json(title, object, options = {}) {\n    options = Object.assign({}, { maxEnumValues: 20, generateEnums: false, generateLengths: false }, options);\n\n    var schema = generator.json(title, object);\n    addSchemaLimits(schema, object, options);\n    return schema;\n}\n\nfunction addSchemaLimits(rootSchema, data, options) {\n\n    const core = new Core(rootSchema);\n    const stats = {};\n    // Queue up the schema updates\n    core.each(rootSchema, data, (schema, value, pointer) => {\n        const schemaPointer = pointer.replace(/(\\d+)/gi, '*').replace(' / ', ' - ');\n        // Detect GUIDs and set min/max length to match data\n        // Also detect formats: date-time, date\n        if (typeof value !== 'object' && typeof value !== 'array') {\n            const stat = stats[schemaPointer] || { schemaUpdateFunctions: [] };\n            if (value.length === 36 && isUUID.anyNonNil(value)) {\n                stat.schemaUpdateFunctions.push((s) => { s.minLength = 36; s.maxLength = 36; });\n            } else if (moment(value, 'YYYY-MM-DD', true).isValid()) {\n                stat.schemaUpdateFunctions.push((s) => s.format = 'date')\n            } else if (moment(value, moment.ISO_8601, true).isValid()) {\n                stat.schemaUpdateFunctions.push((s) => s.format = 'date-time');\n            }\n\n            if (schema.type === 'string') {\n                // TODO: Detect enumeration values.  This is harder to do efficiently inside the each.\n                // If total number of records > 100 but distinct values < 20 assume its an enum.\n                // Count the number of times the value has been used\n                stat.values = stat.values || {};\n                stat.values[value] = (stat.values[value] || 0) + 1;\n\n                // Keep stats on minLength and maxLength\n                if (value.length < (stat.minLength || 10000000)) {\n                    stat.minLength = value.length;\n                }\n                if (value.length > (stat.maxLength || 0)) {\n                    stat.maxLength = value.length;\n                }\n            }\n            stats[schemaPointer] = stat;\n        }\n    });\n\n    // Make the schema updates\n    Object.keys(stats).forEach(pointer => {\n        const stat = stats[pointer];\n        if (options.generateEnums && stat.values) {\n            stat.schemaUpdateFunctions.push((s) => s.enum = Object.keys(stat.values).slice(0, options.maxEnumValues));\n        }\n        if (options.generateLengths && typeof stat.minLength !== 'undefined') {\n            stat.schemaUpdateFunctions.push((s) => {\n                s.minLength = stat.minLength;\n                s.maxLength = stat.maxLength;\n            });\n        }\n\n        updateSchema(rootSchema, pointer, stat.schemaUpdateFunctions)\n    });\n}\n\nfunction updateSchema(rootSchema, pointer, updateFunctions) {\n    if (updateFunctions.length === 0) {\n        return;\n    }\n    const schemaToUpdate = findSchema(rootSchema, pointer);\n    if (schemaToUpdate) {\n        updateFunctions.forEach(fn => {\n            fn(schemaToUpdate);\n        })\n    }\n}\n\nfunction findSchema(rootSchema, pointer) {\n    // Try to find the schema that needs to be updated\n    var steps = pointer.split('/');\n    var schemaToUpdate = rootSchema;\n\n    steps.forEach(step => {\n        if (!schemaToUpdate) {\n            console.log('Could not get schema for pointer', pointer);\n            return;\n        }\n        if (step === '#') { return; }\n        if (step === '*' || Number.isInteger(parseInt(step))) {\n            schemaToUpdate = schemaToUpdate.items;\n        } else {\n            if (schemaToUpdate) {\n                schemaToUpdate = schemaToUpdate.properties[step];\n            }\n        }\n    })\n    return schemaToUpdate;\n}\n\n"]}